# 51CTObuildingBlockChain

用户交互输入进行交易，涉及到公钥私钥地址的生成验证。
一笔交易涉及到交易的结构、输入输出的所有权转移机制、设计到数据签名与验证、默克尔树。
交易添加到区块，就会就行挖矿、涉及到区块结构、真实比特币的序列化、困难度计算、pow挖矿机制。
区块添加到区块链中，涉及到区块链如何连接在一起的、涉及到UTXO、涉及到序列化与反序列化添加到boltDB数据库中。
最后还涉及钱包、涉及到网络编程、比特币网络传输的细节。


go语言实现底层公链总结：
---------------------------------------------------------------------------------------------------------------------

## 功能：
```
1.在控制台通过输入命令行，实现与程序交互(通过os包和flag包实现交互)
2.创建钱包，生成公钥和私钥，并生成对应的钱包地址(也就是比特币地址)。并可将账户多个钱包信息写入文件，
  且也可以从文件中读取账户多个钱包信息。
          注意：因为一个用户可以绑定多张银行卡、一张卡对应一个钱包、所有用户可以有多个钱包，实际
                项目中会构建一个钱包集结构体(map类型),一个钱包地址对应一个钱包对象。
2.用户进行输入或输出转账交易：
      a.根据用户发起转账交易的钱包公钥，会查询出公钥所有未花费输出交易对象的切片,根据这些交易可以算出用户这个转账
        地址的余额。如果余额小于转账金额，那么提示用户错误信息。
      b.如果满足条件，构建新的交易对象，其中注意，余额比转账金额多时，比特币为了遵循输入与输出配平的规则，会将
        剩余的金额转给发起转账交易的钱包地址。之前的余额会被覆盖。
      c.每一笔输入同时也需要上一笔输出所对应的私钥进行签名,所以需要进行数据签名,并放入输入交易的数据签名字段中。
      d.接收转账交易数据，首先会对转账交易数据签名进行验证。
      e.根据当前区块链可以获得最近区块，根据当前交易，最近交易的hash值，最近的高度+1，矿工挖矿生成新的区块。
        将新区块的hash值和新区块的序列化值，以键值对的形式存入数据库中。并将当前区块链中的最近一个区块的hash值
        修改为新的区块的hash值，重新生成区块链。
      f.增加一个区块，更新数据库中所有未花费的输出数据,
3.用户进行完转账后，可以根据地址查询余额，其实就是根据地址截取公钥去utxo中查询余额。
4.创建区块链，并打印区块链
5.构建专门的UTXO数据库桶(存储格式是键值队格式，key：交易ID，value:未花费的输出数组序列化值)
6.构建网络区块链中，两个节点之间的实际交互：
      a.有A，B两节点，B发现A节点，并向A发送版本信息(版本号、区块高度、B节点地址)
      b.A节点获取到B节点的版本信息，会进行区块高度的比较，如果A节点区块高度大于B节点区块高度，那么A节点向B节点
        发起获取区块信息请求。如果A节点区块高度大于B节点区块高度，那么A节点向B节点发送版本信息。
      c.B节点接收到A节点发送的获取区块信息请求。会将自己区块链中所有区块的hash值，返回给A节点。
      d.A节点接收到B节点的信息后，会向B节点发送获取区块数据请求(包含B节点最新区块的hash值)。然后将B节点的信息，去除
        掉最新区块hash值后的结果赋值给一全局变量blockInTransit。
      e.B节点接收到A节点发送的请求数据信息后，根据返回过来的最新区块hash值，获取区块。发送给A节点。
      f.A节点接收到新区块后，将新区块以区块hash，区块序列化值，键值对形式存入数据库，并更新区块链ID。如果blockInTransit
        的长度大于0，那么继续讲最新hash值(blockInTransit[0])发送给B，请求获得最新区块,并将最新hash值提出出blockInTransit
        如果blockInTransit的长度小于0，更新UTXO数据库桶数据。
7.用非关系型数据库bolt
```

## 增加一个区块，更新数据库中所有未花费的输出数据逻辑：
```
      1.打开utxo数据库(存储格式是键值队格式，key：交易ID，value:未花费的输出数组序列化值)
      2.for循环新增区块里面的交易
      3.如果不是coinBase交易，for循环交易中的输入交易，新建一个输出交易数组结构体updateouts，
        根据输入交易的id值，可以数据库中获得未花费的输出数组序列化值，反序列化后获得输出数组，
        for循环输出数组，得到输出交易下标和输出交易对象，如果输出交易下标不等于输入交易中的
        未花费的输出数组序列化值，说明该笔输出交易还是没有被花费，将该笔输出交易对象放入
        updateouts中的输出交易数组中。循环完输出数组后，判断如果updateouts中的输出交易
        数组长度等于0，说明该笔交易的输出交易都已经被花费，那么在数据库中根据输入交易id删除
        数据。如果长度大于0，将updateouts序列化后，存入数据库，覆盖之前key值为输入交易id的value值
      4.如果是coinBase交易，新建一个输出交易数组结构体newOutputs，将交易中的输出交易加入数组结构体中，
        以键值对形式，将交易ID，newOutputs的序列化值存入数据库中。
```

## 矿工挖矿逻辑：
```
      1.系统会初始化一个区块，构建一个工作量证明，包含挖矿难度
      2.定义nonce值为0
      3.for循环，如果目标值nonce小于最大目标值随机数则会一直循环
      4.
      4.如果不小于，nonce自加。如果小于：
      5.根据nonce和工作量证明类构建区块的序列化值(包括：版本号、上一个区块hash值、默克尔根、交易时间、挖矿难度、目标值)
        ，将得到的序列化值进行double，sha256。得到second，转换成大整形currenthash
      6.将当前得到的目标值currenthash与工作量证明类中的难度值(target)作比较，如果小于也就是
        等于-1，说明挖矿成功，那么break跳出循环
      7.返回nonce目标值和区块hash值，根据交易可以生成默克尔根，将这三个值赋值给系统初始化的区块。这就生成了新的区块
```

## 生成默克尔根逻辑：
```
      1.将所有交易地址切片转换成默克尔节点，生成默克尔节点切片
      2.通过双for循环，将所有默克尔节点按照默克尔规则，两两相加，顺序追加到默克尔节点切片
      3.注意：如果默克尔节点切片是基数，在执行步骤2时，最后单出来的节点，会自己加自己，生成新的节点
      4.因为默克尔节点切片再执行2步骤的时候，是顺序追加两两相加的新节点，所以最后一个节点就是默克尔根节点
```


## 数据签名验证逻辑：
```
      1.根据当前输入交易ID，找到对应的前一笔交易，因为当前交易的输入交易不止一笔，所以会得到多比对应的交易，
        实际代码操作中，可构建个make(map[string]Transation)键值对切片，key为对应的交易ID，value为：
        对应的前一笔交易
      2.coinbase交易直接返回true，首先创建当前交易的副本，副本中，将输入交易的数据签名和公钥置空。
      3.构建一条椭圆曲线，cure:=elliptic.P256()
      4.循环副本中的输入交易数组,得到输入交易序号和输入交易对象，循环中，根据输入交易对象ID，在prevTX中可以获得对应的
        前一笔交易，循环中根据交易序号将副本的输入交易对象的数据签名字段置为空，循环中根据交易序号将副本的输入交易对象
        置为对应的前一笔交易的输出交易对象的公钥hash值，将当前交易副本的序列化值进行sha256.Sum256运算，
        赋值给当前交易副本的交易ID。
      5.将输入交易中的数据签名一分为二，并由两个整型数组接收(r,s)，将输入交易中的公钥一分为二，并由两个整型数组接收(x,y)
      6.调用ecdsa.PublicKey方法，生成新的公钥结构体rawPubkey，ecdsa.PublicKey{cure,&x,&y}
      7.调用ecdsa.Verify方法进行解密，返回成功或失败，ecdsa.Verify(&rawPubkey,txcopy.ID,&r,&s)，
        参数：rawPubkey地址、副本交易ID,r地址,s地址
```

## 数据签名逻辑：
```
      1.根据当前输入交易ID，找到对应的前一笔交易，因为当前交易的输入交易不止一笔，所以会得到多比对应的交易，
        实际代码操作中，可构建个make(map[string]Transation)键值对切片prevTX，key为对应的交易ID，value为：
        对应的前一笔交易。
      2.coinbase交易不需要进行签名，首先创建当前交易的副本，副本中，将输入交易的数据签名和公钥置空。
      3.循环副本中的输入交易数组,得到输入交易序号和输入交易对象，循环中，根据输入交易对象ID，在prevTX中可以获得对应的
        前一笔交易，循环中根据交易序号将副本的输入交易对象的数据签名字段置为空，循环中根据交易序号将副本的输入交易对象
        置为对应的前一笔交易的输出交易对象的公钥hash值，将当前交易副本的序列化值进行sha256.Sum256运算，
        赋值给当前交易副本的交易ID。
      4.调用ecdsa.Sign方法传入三个参数（数据签名随机数,私钥指针，当前交易副本的交易ID),该方法会返回两个大整形数据，
        r,s,err := ecdsa.Sign(rand.Reader,&privkey,txcopy.ID)，将两个大整形数据bytes值相加，获得的就是该笔交易的
        输入交易签名signature:=append(r.Bytes(),s.Bytes()...)
```
## 查询公钥对应的所有未输出交易逻辑：
```
      1.构建存储所有未花费交易对象的切片。键值对形式存储、key:交易ID、
                                                      value：所有未花费的输出交易对象
      2.构建存储所有已花费交易对象的切片。键值对形式存储、key所有已经花费交易的hash值
                                                    value交易中已经被花费的输出交易下标切片
      3.循环迭代区块链中的所有区块，从后向前迭代，所以当区块的前一个区块的hash值长度为0时，跳出循环
      4.得到区块，再循环区块中的区块交易
      5.获得交易ID
      6.循环交易中的输出交易数据，得到输出交易下标、输出交易对象
      7.判断如果交易的hash值存在于，以花费交易对象的切片中，至少说明该笔交易存在已未花费的交易
      8.根据交易hash值，获得下标数组，循环该数组。
      9.如果该下标等于输出交易下标，那么跳出循环至，循环交易中的输出交易数据
      10.判断如果交易的hash值不存在于，以花费交易对象的切片中，那么该笔输出交易就是未花费的输出交易
      11.将未花费的输出交易，存入未花费的交易对象切片。
      12.在循环交易中的输出交易方法外，如果输入交易不是coinbase交易，那么所有输入交易对应的输出交易
          都是已花费的交易，将这些输出交易存入已花费交易对象的切片。
      -------------注意以上操作是获得区块链中所有的未花费的输出交易。----------------
      13.要得到某个公钥对应的所有未花费的输出交易，可以循环迭代所有未花费的输出交易对象中的公钥的hash值
        和传递过来的公钥值做比较，相等的话，这个未花费的输出交易对象，就是传递过来的公钥，
        对应的未花费的输出交易。
```
        ---------------------------------------------------------------------------------------------------------------------
            遍历区块链逻辑：
                  1.通过Blockchan(区块链类)初始化BlockChainIterateor(区块链遍历类)。
                  2.创建一个无线for循环
                  3.根据BlockChainIterateor的currenthash(最近区块的hash值),去数据库boit中获取，最近的block序列化值
                  4.将序列化值反序列化，获得最新区块block，然后将最新区块的前一个区块的hash值赋值给BlockChainIterateor的currenthash
                  5.因为是在for循环中，所有会一直从后往前打印区块，当最新区块的前一个区块的hash值长度为0时，代表已经到了创世区块，
                    使用break退出循环
        ---------------------------------------------------------------------------------------------------------------------


        ---------------------------------------------------------------------------------------------------------------------
        私钥和公钥：
                A给B转账，A通过
                          私钥(一个随机数、一条曲线，通过椭圆曲线算法生成私钥结构体,结构体中的D属性的Bytes值就是私钥)
                              对交易信息进行加密，生成
                          数据签名(通过，一个随机数、私钥、需要加密数据的sha256值，调用ecdas.Sign方法,生成r，s大整数，
                          将r和s的bytes值相加就得到数据签名)，
                              B接收到输入信息后，可以用
                          公钥(私钥结构体中的Publickey的X与Y的Bytes值相加)对
                          数据签名进行验证(通过曲线、公钥的x和y的大整数值，调用ecdsa.PublicKey方法生成公钥结构体，通过
                              公钥结构体，需要加密数据的sha256值，r，s调用ecdsa.Verify判断是否验证成功)，
                              来判断该笔转账是否是A的
        ---------------------------------------------------------------------------------------------------------------------

        ---------------------------------------------------------------------------------------------------------------------
        比特币地址由三部分组成：Base58Encode(Version+publickeyhash+Checksum)
              Version 版本号，比特币主网当中版本号占一个字节为0x00
              Public key hash 公钥的hash值：
                  1.将公钥进行sha256运算得到新的hash值
                  2.调用ripemd160类，再次对新的hash值进行hash运算，得到公钥hash值
              Checksum：版本号拼接公钥hash值得到的byte值，进行double sha256，结果的前四个值

        ---------------------------------------------------------------------------------------------------------------------


        ---------------------------------------------------------------------------------------------------------------------
        go自带序列和反序列化方法：
                        1.gob.NewDecoder(参数).Encode(参数)反序列化
                        2.gob.NewEncoder(参数).Encode(参数)序列化
        ---------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
    Block字段描述(块)：
	     Version int32:版本号，
	     PrevBlockHash []byte:前一个区块的hash值
	     Merkleroot  []byte:默克尔树根（当前区块所有交易的hash值）
	     Hash  []byte:当前区块的hash（包含当前区块，前一个区块的hash值、默克尔树根、交易时间、挖矿难度、目标值的字节数组做双sha256获得）
       Time int32:交易时间
       Bits int32:挖矿难度
	     Nonce int32：随机目标值（Bits中包含Nonce）
	     Transations []*Transation：当前区块的所有交易
	     Height  int32：区块高度
---------------------------------------------------------------------------------------------------------------------


---------------------------------------------------------------------------------------------------------------------
    BlockChan字段描述(区块链)：
        tip []byte 最近一个区块的hash值
        db * bolt.DB 存储当前区块链，专门的数据库
        -----------------------------------------
            BlockChainIterateor字段描述(遍历区块链)：
                currenthash []byte 最近一个区块的hash值
                db * bolt.DB 存储当前区块链，专门的数据库 以区块hash，区块序列化值，键值对形式存入数据库


---------------------------------------------------------------------------------------------------------------------


---------------------------------------------------------------------------------------------------------------------
    Transation字段描述(交易)：
        ID  []byte：当前交易的hash值：将交易序列化，对交易的序列化值进行sha256哈希
        Vin []TXInput：输入交易
        Vout []TXOutput：输出交易
        ----------------------------------------------
            TXInput字段描述：
                Txid  []byte：前一笔交易的ID
                Voutindex  int：前一笔输出引用的序号
                Signature  []byte：数字签名
                          1.调用ecdsa.Sign方法传入三个参数（数据签名随机数,私钥指针，当前交易除去数据签名，交易结构体的hash值）
                              注意交易结构体中的TXInput.Pubkey被修改为其前一笔交易对应的输出的公钥hash值
                                          r,s,err := ecdsa.Sign(rand.Reader,&privkey,txcopy.ID)
                          2.将r和s的bytes值做拼接，获得数据签名

                Pubkey   []byte：公钥
        -----------------------------------------------
            TXOutput字段描述：
                Value  int：输出金额
                PubkeyHash   []byte：公钥的hash值
---------------------------------------------------------------------------------------------------------------------


---------------------------------------------------------------------------------------------------------------------
    MerkleTree字段描述(默克尔树)：
        RootNode  *MerkleNode：默克尔根节点
        ---------------------------------------------
            MerkleNode字段描述:
                Left   *MerkleNode：左节点
                Right  *MerkleNode：右节点
                Data   []byte：交易地址切片

---------------------------------------------------------------------------------------------------------------------


---------------------------------------------------------------------------------------------------------------------
    ProofOfWork字段描述(工作量证明)：
      block  *Block：区块结构体
      target   *big.int：难度值

---------------------------------------------------------------------------------------------------------------------


---------------------------------------------------------------------------------------------------------------------
    Wallet字段描述(钱包)：
        PrivateKey ecdsa.PrivateKey：私钥
        Publickey []byte：公钥
        -----------------------------------------
        Wallets字段描述(账户多个钱包):比如:一个微信账户可以绑定多张卡片
            Walletsstore  map[string]*Wallet: 键值对形式存储、string对应的是钱包的比特币地址(通过公钥和私钥生成)
---------------------------------------------------------------------------------------------------------------------

